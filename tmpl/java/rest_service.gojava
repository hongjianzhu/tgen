package {{ .Namespace }};

/**
 * This file is auto-generated by tgen
 * Don't change manually
 */

import android.util.Log;

import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.Response.Listener;
import com.android.volley.VolleyError;
import com.daigou.selfstation.utils.JsonUtils;
import com.daigou.selfstation.utils.NetworkError;
import com.daigou.selfstation.utils.RpcRequest;
import com.daigou.selfstation.system.AppUrl;
import com.fasterxml.jackson.core.JsonParser;
import com.google.gson.Gson;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;

{{ $js := . -}}

public class {{ .Service.Name}}Service {
    private static final Gson gson = new Gson();
    private static int msgID = 1;
    private static RequestQueue queue;

    private {{ .Service.Name}}Service() {
        // Constructor hidden because this is a singleton
    }

    public static void init(RequestQueue requestQueue) {
        queue = requestQueue;
    }

    private static String getMsgID() {
        msgID += 1;
        return Integer.toString(msgID);
    }
{{ range $k, $method := $.Service.Methods }}
    public static void {{ $method.Name }}({{ $method | $js.BaseJava.AssembleParams }}) {
        RpcRequest req = new RpcRequest(Request.Method.POST, AppUrl.kJsonRpcCoreUrl + "{{ $js.Service.Name }}/{{ $method.Name }}",
            new Response.Listener<String>() {
                @Override
                public void onResponse(String response) {
                    {{- if $method.ReturnType }}
                    try {
                        {{ $method.ReturnType | $js.BaseJava.ObjectTypecast }} result;
                        JsonParser jp = JsonUtils.getJsonRpcResult(response);
                        {{ if eq $method.ReturnType.Name "list" }}
                        {{- $innertype := $js.GetInnerType $method.ReturnType -}}
                        {{- if eq $innertype "String" }}
                        result = JsonUtils.readStringList(jp);
                        {{- else }}
                        result = {{ $innertype }}.fromJSONArray(jp);
                        {{- end }}
                        {{- else }}
                        {{- $type := $js.ObjectTypecast $method.ReturnType -}}
                        {{ if eq $type "String" }}
                        jp.nextToken();
                        result = jp.getText();
                        {{- else if eq $type "Integer" }}
                        jp.nextToken();
                        result = jp.getIntValue();
                        {{- else if eq $type "Boolean" }}
                        jp.nextToken();
                        result = jp.getBooleanValue();
                        {{- else }}
                        result = {{ $type }}.fromJSON(jp);
                        {{- end }}
                        {{- end }}

                        jp.close();

                        listener.onResponse(result);
                    } catch (IOException ex) {
                        Log.d("ex", ex.toString());
                        Log.d("jsonObject", response);
                        listener.onResponse(null);
                    }
                    {{- else -}}
                    if (listener != null) {
                        listener.onResponse(true);
                    }
                    {{- end }}
                }
            }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                {{- if $method.ReturnType }}
                if (error.getCause() != null && error.getCause() instanceof java.net.UnknownHostException) {
                    NetworkError.unKnowHost();
                } else if (error.networkResponse != null) {
                    NetworkError.networkError(error.networkResponse.statusCode);
                } else {
                    listener.onResponse(null);
                }
                {{- end }}
            }
        }) {
            @Override
            public byte[] getBody() {
                {{- if $method.Arguments }}
                HashMap<String, Object> msg = new HashMap<String, Object>();
                {{- range $arg := $method.Arguments }}
                msg.put("{{ $arg.Name }}", {{ $arg.Name }});
                {{- end }}

                return gson.toJson(msg).getBytes(Charset.forName("UTF-8"));
                {{- else }}
                return "".getBytes(Charset.forName("UTF-8"));
                {{- end }}
            }
        };
        queue.add(req);
    }
{{ end -}}
}
